# Tests for the 'DiffUtil' package. -*- tcl -*-
#
# Copyright (c) 2004 by Peter Spjuth. All rights reserved.
#
# $Revision: 1.8 $

package require DiffUtil

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import ::tcltest::*
}

# There are differences between the C and the Diff result.
tcltest::testConstraint CDiff \
        [expr {[info proc DiffUtil::ExecDiffFiles] == ""}]
tcltest::testConstraint TclDiff \
        [expr {[info proc DiffUtil::ExecDiffFiles] != ""}]
# Some tests are not expected to work with the LCS fallback
tcltest::testConstraint NoLcsDiff [expr ![info exists ::env(DIFFUTIL_DIFFNAME)]]

#----------------------------------------------------------------------

# A wrapper to simplify calling
proc RunTest {list1 list2 args} {
    set ch [open _diff_1 wb]
    if {[llength $list1] > 0} {
        puts $ch [join $list1 \n]
    }
    close $ch
    set ch [open _diff_2 wb]
    if {[llength $list2] > 0} {
        puts $ch [join $list2 \n]
    }
    close $ch

    set apa [catch {eval DiffUtil::diffFiles $args _diff_1 _diff_2} res]
    file delete -force _diff_1 _diff_2
    if {$apa} {
        return [list $apa $res]
    }
    return $res
}

#----------------------------------------------------------------------

test difffiles-1.1 {standard cases} {
    set l1 {a b c d   f g h i j k l}
    set l2 {  b c d e f g x y   k l}
    RunTest $l1 $l2
} [list {1 1 1 0} {5 0 4 1} {7 3 7 2}]

test difffiles-1.2 {standard cases, error} -body {
    set l1 {a b c d   f g h i j k l}
    set l2 {  b c d e f g x y   k l}
    RunTest $l1 $l2 -hubba
} -result [list 1 {bad option "-hubba"*}] -match glob

test difffiles-1.3 {standard cases, error} -body {
    DiffUtil::diffFiles a
} -returnCodes 1 -result "wrong # args*" -match glob

test difffiles-2.1 {alignment, no align} {
    set l1 {a b c d  }
    set l2 {a   c d b}
    RunTest $l1 $l2
} [list {2 1 2 0} {5 0 4 1}]

test difffiles-2.2 {alignment} {
    set l1 {a     b c d}
    set l2 {a c d b    }
    RunTest $l1 $l2 -align {2 4}
} [list {2 0 2 2} {3 2 5 0}]

test difffiles-2.3 {alignment, error} -body {
    DiffUtil::diffFiles -align {1} a b
} -returnCodes 1 -result {bad align*} -match glob

test difffiles-2.4 {alignment, impossible align ignored} {
    set l1 {a     b c d}
    set l2 {a c d b    }
    RunTest $l1 $l2 -align {2 4 3 2}
} [list {2 0 2 2} {3 2 5 0}]

test difffiles-2.5 {alignment+range} -body {
    set l1 {a     b c d e}
    set l2 {x c d b     y}
    RunTest $l1 $l2 -align {2 4} -range {2 4 2 4}
} -result [list {2 0 2 2} {3 2 5 0}]

test difffiles-2.6 {alignment, switched order} {
    set l1 {a     b c d e f g    }
    set l2 {a c d b         g e f}
    RunTest $l1 $l2 -align {7 5 2 4}
} [list {2 0 2 2} {3 4 5 0} {8 0 6 2}]

test difffiles-2.7.1 {alignment, no align} {
    set l1 {a b c  d }
    set l2 {e f g  d }
    RunTest $l1 $l2
} [list {1 3 1 3}]

test difffiles-2.7.2 {alignment} {
    set l1 {    a b c d }
    set l2 {e f g     d }
    RunTest $l1 $l2 -align {1 3}
} [list {1 0 1 2} {1 1 3 1} {2 2 4 0}]

test difffiles-2.7.3 {alignment} {
    set l1 {a   b c d }
    set l2 {e f g   d }
    RunTest $l1 $l2 -align {1 1 2 3}
} [list {1 1 1 1} {2 0 2 1} {2 1 3 1} {3 1 4 0}]

test difffiles-2.7.4 {alignment} {
    set l1 {a b   c  d }
    set l2 {  e f g  d }
    RunTest $l1 $l2 -align {2 1 3 3}
} [list {1 1 1 0} {2 1 1 1} {3 0 2 1} {3 1 3 1}]

test difffiles-3.1 {ignore space} {
    set l1 {a {b c} d e f {g h}  i}
    set l2 {a {bc}  x e f {g  h} i}
    RunTest $l1 $l2
} [list {2 2 2 2} {6 1 6 1}]

test difffiles-3.2 {ignore space} {
    set l1 {a {b c} d e f {g h}  i}
    set l2 {a {bc}  x e f {g  h} i}
    RunTest $l1 $l2 -b
} [list {2 2 2 2}]

test difffiles-3.3 {ignore space} {
    set l1 {a {b c} d e f {g h}  i}
    set l2 {a {bc}  x e f {g  h} i}
    RunTest $l1 $l2 -w
} [list {3 1 3 1}]


test difffiles-4.1 {range} {
    set l1 {a bc d e f gh  i}
    set l2 {a xy x e f ghh i}
    RunTest $l1 $l2 -range {3 5 3 6}
} [list {3 1 3 1} {6 0 6 1}]

test difffiles-4.2 {range} -body {
    DiffUtil::diffFiles -range {3 5 3} a b
} -returnCodes 1 -result {bad range*} -match glob

test difffiles-4.3 {range} -body {
    DiffUtil::diffFiles -range {-3 5 3 5} a b
} -returnCodes 1 -result {bad range*} -match glob


test difffiles-5.1 {priority} {NoLcsDiff} {
    # The changed block is kept together
    set l1 {a b c d       e}
    set l2 {a b c d f e E e}
    RunTest $l1 $l2
} [list {5 0 5 3}]

test difffiles-5.2 {priority} {
    # No prio here, just a reference for the following nocase
    set l1 {a b c d   e}
    set l2 {a b c d f e E}
    RunTest $l1 $l2
} [list {5 0 5 1} {6 0 7 1}]

test difffiles-5.3 {priority} {CDiff} {
    # Same case as before but with prio
    # The correct case has priority even if it means two changes
    set l1 {a b c d   e}
    set l2 {a b c d f e E}
    RunTest $l1 $l2 -nocase
} [list {5 0 5 1} {6 0 7 1}]

test difffiles-5.4 {priority} {NoLcsDiff} {
    # Same case again but no correct case, single block preferred
    set l1 {a b c d     e}
    set l2 {a b c d f E E}
    RunTest $l1 $l2 -nocase
} [list {5 0 5 2}]

test difffiles-5.5 {priority} {
    # Here efgh can match in two places, the first is chosen
    set l1 {a b c d   e f g h             i j k l}
    set l2 {a b c d X e f g h Y e f g h Z i j k l}
    RunTest $l1 $l2
} [list {5 0 5 1} {9 0 10 6}]

test difffiles-5.6 {priority} {NoLcsDiff} {
    # Here efgh can match in two places, the second is chosen since it
    # keeps things together
    set l1 {a b c d             e f g h i j k l}
    set l2 {a b c d X e f g h Y e f g h i j k l}
    RunTest $l1 $l2
} [list {5 0 5 6}]

test difffiles-5.7 {priority} {CDiff} {
    # Multiple blocks starting alike where one block is removed
    set l1 {a b c d e {} a b f g h {} a b i j k}
    set l2 {a b c d e {}              a b i j k}
    # 6    {a b c d e              {} a b i j k}
    # 7    {a b c d e {}              a b i j k}
    # 8    {a b c d e {} a              b i j k}
    # 9    {a b c d e {} a b              i j k}
    list [RunTest $l1 $l2] [RunTest $l2 $l1]
    # Any start line from 6-9 are correct bet from a visual point of
    # view 6 or 7 are preferable.
} [list [list {7 6 7 0}] [list {7 0 7 6}]]

test difffiles-5.7.2 {priority} {TclDiff} { # Same as 5.7, tcl version
    set l1 {a b c d e {} a b f g h {} a b i j k}
    set l2 {a b c d e {}              a b i j k}
    RunTest $l1 $l2
} [list {9 6 9 0}]

test difffiles-5.8 {priority} {
    # Multiple blocks ending alike where one block is removed
    set l1 {a b c d e {} f g h d e {} i j k d e}
    set l2 {a b c d e {}              i j k d e}
    RunTest $l1 $l2
    # Any start line from 6-9 are correct bet from a visual point of
    # view 6 or 7 are preferable.
} [list {7 6 7 0}]

test difffiles-6.1 {noempty} -body {
    set l1 {a b c {} d {}   e f g}
    set l2 {a b c {}   {} d e f g}
    RunTest $l1 $l2
} -result [list {5 1 5 0} {7 0 6 1}]

test difffiles-6.2 {noempty} -constraints {CDiff} -body {
    set l1 {a b c {}    d {} e f g}
    set l2 {a b c {} {} d    e f g}
    RunTest $l1 $l2 -noempty
} -result [list {5 0 5 1} {6 1 7 0}]

test difffiles-6.3 {noempty} -constraints {CDiff} -body {
    # Stretches of empty should still be handled
    set l1 {a b c {} {}    d {} e f g}
    set l2 {a b c {} {} {} d    e f g}
    RunTest $l1 $l2 -noempty
} -result [list {6 0 6 1} {7 1 8 0}]

test difffiles-6.4 {noempty} -constraints {CDiff} -body {
    # Stretches of empty should still be handled
    set l1 {a b c {} {} {} d {} {} e f g}
    set l2 {a b c {} {} {} d {} {} e h g}
    RunTest $l1 $l2 -noempty
} -result [list {11 1 11 1}]

test difffiles-6.5 {noempty} -constraints {CDiff} -body {
    # Long strech of empty, to trigger reallocation
    set l1 {a b c {} {} {} d {} {} e f g {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} x}
    set l2 {a b c {} {} {} d {} {} e h g {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} x}
    RunTest $l1 $l2 -noempty
} -result [list {11 1 11 1}]

test difffiles-6.6 {noempty} -constraints {CDiff} -body {
    # Within a change group, empty are left unmatched
    set l1 {a b c d e {} f g}
    set l2 {a b c d q {} x g}
    RunTest $l1 $l2 -noempty
} -result [list {5 3 5 3}]

test difffiles-7.1 {ignore digit} -body {
    set l1 {a b123c x b02c   b13c d}
    set l2 {a         b02c x      d}
    list [RunTest $l1 $l2] [RunTest $l1 $l2 -nodigit]
} -result [list [list {2 2 2 0} {5 1 3 1}] [list {4 2 4 0}]]

test difffiles-7.2 {ignore digit} -body {
    set l1 {a b123 12c 456   a76b93u x}
    set l2 {a b2   1c  7890  a0b12u  x}
    RunTest $l1 $l2 -nodigit
} -result {}

test difffiles-7.3.1 {ignore digit, preference} {CDiff} {
    set l1 {a b123 b456 x}
    set l2 {a b123      x}
    set l3 {a b222      x}
    set l4 {a b456      x}
    list [RunTest $l1 $l2 -nodigit] \
            [RunTest $l1 $l3 -nodigit] \
            [RunTest $l1 $l4 -nodigit]
} [list [list {3 1 3 0}] [list {3 1 3 0}] [list {2 1 2 0}]]

test difffiles-7.3.2 {ignore digit, preference} {TclDiff} {
    # Tcl version fully ignores, and cannot prefer the exact match
    set l1 {a b123 b456 x}
    set l2 {a b123      x}
    set l3 {a b222      x}
    set l4 {a b456      x}
    list [RunTest $l1 $l2 -nodigit] \
            [RunTest $l1 $l3 -nodigit] \
            [RunTest $l1 $l4 -nodigit]
} [list [list {3 1 3 0}] [list {3 1 3 0}] [list {3 1 3 0}]]

test difffiles-8.1 {flag -regsub} {
    set l1 {axa byb aa bb}
    set l2 {aya bxb ee ff}
    list [RunTest $l1 $l2] [RunTest $l1 $l2 -regsub {{x|y} {}}]
} [list [list {1 4 1 4}] [list {3 2 3 2}]]

test difffiles-8.2 {flag -regsub} {
    set l1 {axa byb axa bb}
    set l2 {    aya bxb ee ff}
    list [RunTest $l1 $l2] [RunTest $l1 $l2 -regsub {{.*(y|x).*} {\1}}]
} [list [list {1 4 1 4}] [list {1 1 1 0} {4 1 3 2}]]

test difffiles-8.3 {flag -regsub} {
    set l1 {axa byb epe bb}
    set l2 {apa bqb exe ff}
    list [RunTest $l1 $l2] \
            [RunTest $l1 $l2 -regsubleft {{x|y} {}} -regsubright {{p|q} {}}] \
            [RunTest $l1 $l2 -regsub {{x|y} {}} -regsub {{p|q} {}}]
} [list [list {1 4 1 4}] [list {3 2 3 2}] [list {4 1 4 1}]]

test difffiles-9.1 {hash} {
    # Different elements that hash to the same thing.
    # Hash is currenctly hash = hash*129+char, and run over utf-8 string.
    # \x83 becomes \xc2 \x83 in utf-8.
    set l1 {a ab\x83 c}
    set l2 {a ac\x42\x02 c}
    RunTest $l1 $l2
} [list {2 1 2 1}]

test difffiles-10.1 {result style} -constraints {CDiff} -body {
    DiffUtil::diffFiles -result {} {}
} -returnCodes 1 -result "wrong # args*" -match glob

test difffiles-10.2 {result style} -constraints {CDiff} -body {
    DiffUtil::diffFiles -result gurka {} {}
} -returnCodes 1 -result {bad result style "gurka": must be diff or match}

test difffiles-10.3 {result style} {CDiff} {
    set l1 {a b c}
    set l2 {a d c}
    RunTest $l1 $l2 -result diff
} [list {2 1 2 1}]

test difffiles-10.4 {result style} {CDiff} {
    set l1 {a b c}
    set l2 {a d c}
    RunTest $l1 $l2 -result match
} [list {1 3} {1 3}]

test difffiles-10.5 {result style} {CDiff} {
    set l1 {a b c d   f g h i j k l}
    set l2 {  b c d e f g x y   k l}
    RunTest $l1 $l2 -result match
} [list {2 3 4 5 6 10 11} {1 2 3 5 6 9 10}]

test difffiles-11.1 {channel config} {CDiff} {
    set l1 {a b c}
    set l2 {a d c}
    RunTest $l1 $l2 -encoding iso8859-1 -translation lf
} [list {2 1 2 1}]

test difffiles-11.2 {channel config} -constraints {CDiff} -body {
    set l1 {a b c}
    set l2 {a d c}
    RunTest $l1 $l2 -encoding gurkmeja
} -result {1 {unknown encoding "gurkmeja"}}

test difffiles-11.3 {channel config} -constraints {CDiff} -body {
    set l1 {a b c}
    set l2 {a d c}
    RunTest $l1 $l2 -translation gurkmeja
} -result {1 {bad value for -translation: must be one of auto, binary, cr, lf, crlf, or platform}}

test difffiles-11.4 {channel config} {CDiff} {
    set l1 {a \xc2\x82 c}
    set l2 {a \x82 c}
    list [RunTest $l1 $l2 -translation binary] [RunTest $l1 $l2 -encoding utf-8]
} [list [list {2 1 2 1}] {}]
